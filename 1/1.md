# Lesson 1
*meow!*

## Our progress so far:
* The player’s ball can move and look around
* That’s it (but good work still!)

## Objectives:
* Make the camera third-person
* Add jumping
* Add collectible pickups

## Some prerequisite physics
I realized we haven’t talked much about what vectors and quaternions even are.
We'll be working with them everywhere so it's SUPER important to know the fundamentals.
Starting from the ground up:

### Scalar
Google definition:
> (of a quantity) having only magnitude, not direction.

Magnitude means size, or *scale*.
Scalars are quantities that ONLY have scale, most commonly stored as a `float` or `int`.
Note that `float` and `int` are signed types, so if the result of a calculation can be either positive or negative, they CAN have direction.
In that case they wouldn't represent a scalar quantity but a 1-dimensional vector.

### Vector
Google definition:
> a quantity having direction as well as magnitude

When we use vectors in gamedev, we're almost certainly working with their cartesian representation.
That means each component of a vector is the distance from zero in it's respective spatial dimension.

![Example of a one and two dimensional vector showing the relationship between cartesian components and magnitude](example.png)

In Unity, the `Vector3` structure appears EVERYWHERE.
We use vectors to represent position, scale, direction, offset, force, mesh verticies, etc.
If it exists in 3D, it's a vector. 

Manipulating vectors via airthmetic enables us to do a bunch of cool stuff. Like moving!

```cs
[RequireComponent(typeof(Rigidbody))]
public class Player : MonoBehaviour
{
    public float speed = 3;

    private Rigidbody rb;

    void Start()
    {
        rb = GetComponent<Rigidbody>();
    }

    void FixedUpdate()
    {
        // Unity's input system abstracts away WASD into the "Horizontal" and "Vertical" axes
        // which range from -1 to +1, making it super convenient to work with.
        float horizontal = Input.GetAxis("Horizontal");
        float vertical = Input.GetAxis("Vertical");

        Vector3 inputDirection = new Vector3(horizontal, 0, vertical);

        // If the player presses W and D at the same time, inputDirection would be (1, 0, 1).
        // There's a problem with this. The magnitude of (1, 0, 1) is the square root of 2,
        // approx 1.4. This would result in the player going 40% faster by moving diagonally,
        // which isn't desirable. To make the vector always have a magnitude of 1, we need to
        // normalize it.
        inputDirection.Normalize();

        rb.AddForce(speed * inputDirection, ForceMode.Force);
    }
}
```

In this example, we construct a *unit vector* from the player's WASD input.
A unit vector is just a vector that has a magnitude of 1.
When you multiply a vector by a scalar, the direction stays the same but the magnitude gets multiplied.

So when we do `rb.AddForce(speed * inputDirection, ...` we're effectively pushing the player `speed` meters per second in the direction of `inputDirection`.

That's cool and all, but now I want to jump!

```cs
[RequireComponent(typeof(Rigidbody))]
public class Player : MonoBehaviour
{
    public float speed = 3;
    public float jumpForce = 5;

    private Rigidbody rb;

    void Start()
    {
        rb = GetComponent<Rigidbody>();
    }

    void FixedUpdate()
    {
        float horizontal = Input.GetAxis("Horizontal");
        float vertical = Input.GetAxis("Vertical");

        Vector3 inputDirection = new Vector3(horizontal, 0, vertical);

        inputDirection.Normalize();

        rb.AddForce(speed * inputDirection, ForceMode.Force);

        if (Input.GetButtonDown("Jump"))
        {
            // Use ForceMode.Impulse for forces that happen instantly 
            rb.AddForce(jumpForce * Vector3.up, ForceMode.Impulse);
        }
    }
}
```

In this example, the `jumpForce` scalar is multiplied with the `Vector3.up` constant.
Multiplying a vector by a scalar multiplies each component of the vector by the scalar.

`jumpForce * Vector3.up` does the same thing as `new Vector3(jumpForce * 0, jumpForce * 1, jumpForce * 0)`.


### Quaternion



[Skim through the Unity docs page about vectors for more about vector arithmetic.](https://docs.unity3d.com/Manual/VectorCookbook.html)

## Third-person camera
When we implement something, we need to know what the task requires. What does a third-person camera require?
* Something to look at: We need a reference to the player’s Transform so we can track the player’s position.
* Distance: It’s good practice to make everything configurable when possible, so this should be a variable.
* Camera rotation: We want to move AND rotate the camera to face the player. This involves mouse movement, rotation, and offset. The sensitivity of the cursor should be configurable too.

How do we fulfill these requirements? Fortunately Unity provides some useful tools to handle most of the math:
* [Quaternion.AngleAxis(float angle, Vector3 axis)](https://docs.unity3d.com/ScriptReference/Quaternion.AngleAxis.html)
* [Transform.LookAt(Transform target, Vector3 worldUp = Vector3.up)](https://docs.unity3d.com/ScriptReference/Transform.LookAt.html)
